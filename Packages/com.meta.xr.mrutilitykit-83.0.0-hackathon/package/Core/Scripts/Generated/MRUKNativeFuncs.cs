/*
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 * All rights reserved.
 *
 * Licensed under the Oculus SDK License Agreement (the "License");
 * you may not use the Oculus SDK except in compliance with the License,
 * which is provided at the time of installation or download, or which
 * otherwise accompanies this software in either electronic or hard copy form.
 *
 * You may obtain a copy of the License at
 *
 * https://developer.oculus.com/licenses/oculussdk/
 *
 * Unless required by applicable law or agreed to in writing, the Oculus SDK
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// @generated by `buck2 run //arvr/projects/mixedreality/libraries/mrutilitykit:build_and_deploy unity`

using System;
using System.Runtime.InteropServices;
using UnityEngine;

namespace Meta.XR.MRUtilityKit
{
    internal static unsafe class MRUKNativeFuncs
    {
        public enum MrukSceneModel
        {
            V2FallbackV1 = 0,
            V1 = 1,
            V2 = 2,
        }

        public enum MrukLogLevel
        {
            Debug = 0,
            Info = 1,
            Warn = 2,
            Error = 3,
        }

        public enum MrukResult
        {
            Success = 0,
            ErrorInvalidArgs = 1,
            ErrorUnknown = 2,
            ErrorInternal = 3,
            ErrorDiscoveryOngoing = 4,
            ErrorInvalidJson = 5,
            ErrorNoRoomsFound = 6,
            ErrorInsufficientResources = 7,
            ErrorStorageAtCapacity = 8,
            ErrorInsufficientView = 9,
            ErrorPermissionInsufficient = 10,
            ErrorRateLimited = 11,
            ErrorTooDark = 12,
            ErrorTooBright = 13,
            ErrorNotReady = 14,
            ErrorUnsupported = 15,
        }

        public enum MrukSurfaceType
        {
            None = 0,
            Plane = 1,
            Volume = 2,
            Mesh = 4,
            All = 7,
        }

        public enum MrukLabel
        {
            Floor = 1,
            Ceiling = 2,
            WallFace = 4,
            Table = 8,
            Couch = 16,
            DoorFrame = 32,
            WindowFrame = 64,
            Other = 128,
            Storage = 256,
            Bed = 512,
            Screen = 1024,
            Lamp = 2048,
            Plant = 4096,
            WallArt = 8192,
            SceneMesh = 16384,
            InvisibleWallFace = 32768,
            Unknown = 131072,
            InnerWallFace = 262144,
            Tabletop = 524288,
            SittingArea = 1048576,
            SleepingArea = 2097152,
            StorageTop = 4194304,
        }

        public enum MrukTrackableType
        {
            None = 0,
            Keyboard = 1,
            Qrcode = 2,
        }

        public enum MrukMarkerPayloadType
        {
            None = 0,
            InvalidQrcode = 1,
            StringQrcode = 2,
            BinaryQrcode = 3,
        }

        public enum MrukEnvironmentRaycastStatus
        {
            Hit = 1,
            NoHit = 2,
            HitPointOccluded = 3,
            HitPointOutsideFov = 4,
            RayOccluded = 5,
            InvalidOrientation = 6,
            Max = 2147483647,
        }

        public enum MrukEnvironmentRaycasterStatus
        {
            Stopped = 0,
            Creating = 1,
            Ready = 2,
        }

        public delegate void LogPrinter(MrukLogLevel logLevel, char* message, uint length);

        public delegate void MrukOnPreRoomAnchorAdded(ref MrukRoomAnchor roomAnchor, IntPtr userContext);

        public delegate void MrukOnRoomAnchorAdded(ref MrukRoomAnchor roomAnchor, IntPtr userContext);

        public delegate void MrukOnRoomAnchorUpdated(ref MrukRoomAnchor roomAnchor, ref Guid oldRoomAnchorUuid, [MarshalAs(UnmanagedType.U1)] bool significantChange, IntPtr userContext);

        public delegate void MrukOnRoomAnchorRemoved(ref MrukRoomAnchor roomAnchor, IntPtr userContext);

        public delegate void MrukOnSceneAnchorAdded(ref MrukSceneAnchor sceneAnchor, IntPtr userContext);

        public delegate void MrukOnSceneAnchorUpdated(ref MrukSceneAnchor sceneAnchor, [MarshalAs(UnmanagedType.U1)] bool significantChange, IntPtr userContext);

        public delegate void MrukOnSceneAnchorRemoved(ref MrukSceneAnchor sceneAnchor, IntPtr userContext);

        public delegate void MrukOnDiscoveryFinished(MrukResult result, IntPtr userContext);

        public delegate void MrukOnTrackersConfigured(MrukResult result, IntPtr userContext);

        public delegate void MrukOnTrackableAdded(ref MrukTrackable trackable, IntPtr userContext);

        public delegate void MrukOnTrackableUpdated(ref MrukTrackable trackable, IntPtr userContext);

        public delegate void MrukOnTrackableRemoved(ref MrukTrackable trackable, IntPtr userContext);

        public delegate Pose TrackingSpacePoseGetter();

        public delegate void TrackingSpacePoseSetter(Pose pose);

        [StructLayout(LayoutKind.Sequential)]
        public struct MrukLabelFilter
        {
            public uint surfaceType;
            public uint includedLabels;
            [MarshalAs(UnmanagedType.U1)] public bool includedLabelsSet;
        }

        [StructLayout(LayoutKind.Sequential)]
        public struct MrukPolygon2f
        {
            public Vector2[] points;
            public uint numPoints;
        }

        [StructLayout(LayoutKind.Sequential)]
        public struct MrukMesh2f
        {
            public Vector2* vertices;
            public uint numVertices;
            public uint* indices;
            public uint numIndices;
        }

        [StructLayout(LayoutKind.Sequential)]
        public struct MrukMesh3f
        {
            public Vector3* vertices;
            public uint numVertices;
            public uint* indices;
            public uint numIndices;
        }

        [StructLayout(LayoutKind.Sequential)]
        public struct MrukVolume
        {
            public Vector3 min;
            public Vector3 max;
        }

        [StructLayout(LayoutKind.Sequential)]
        public struct MrukPlane
        {
            public float x;
            public float y;
            public float width;
            public float height;
        }

        [StructLayout(LayoutKind.Sequential)]
        public struct MrukSceneAnchor
        {
            public ulong space;
            public Guid uuid;
            public Guid roomUuid;
            public Guid parentUuid;
            public Pose pose;
            public MrukVolume volume;
            public MrukPlane plane;
            public MrukLabel semanticLabel;
            public Vector2* planeBoundary;
            public uint* globalMeshIndices;
            public Vector3* globalMeshPositions;
            public uint planeBoundaryCount;
            public uint globalMeshIndicesCount;
            public uint globalMeshPositionsCount;
            [MarshalAs(UnmanagedType.U1)] public bool hasVolume;
            [MarshalAs(UnmanagedType.U1)] public bool hasPlane;
        }

        [StructLayout(LayoutKind.Sequential)]
        public struct MrukRoomFace
        {
            public Guid uuid;
            public Guid parentUuid;
            public MrukLabel semanticLabel;
            public uint* indices;
            public uint indicesCount;
        }

        [StructLayout(LayoutKind.Sequential)]
        public struct MrukRoomMesh
        {
            public Vector3* vertices;
            public MrukRoomFace* faces;
            public uint verticesCount;
            public uint facesCount;
        }

        [StructLayout(LayoutKind.Sequential)]
        public struct MrukRoomAnchor
        {
            public MrukSceneModel sceneModel;
            public ulong space;
            public Guid uuid;
            public Pose pose;
            public MrukRoomMesh roomMesh;
        }

        [StructLayout(LayoutKind.Sequential)]
        public struct MrukTrackable
        {
            public MrukTrackableType trackableType;
            public MrukMarkerPayloadType markerPayloadType;
            public ulong space;
            public ulong entityId;
            public Guid uuid;
            public Pose pose;
            public MrukVolume volume;
            public MrukPlane plane;
            public Vector2* planeBoundary;
            public byte* payload;
            public uint planeBoundaryCount;
            public uint payloadCount;
            [MarshalAs(UnmanagedType.U1)] public bool hasVolume;
            [MarshalAs(UnmanagedType.U1)] public bool hasPlane;
            [MarshalAs(UnmanagedType.U1)] public bool isTracked;
        }

        [StructLayout(LayoutKind.Sequential)]
        public struct MrukEventListener
        {
            public MrukOnPreRoomAnchorAdded onPreRoomAnchorAdded;
            public MrukOnRoomAnchorAdded onRoomAnchorAdded;
            public MrukOnRoomAnchorUpdated onRoomAnchorUpdated;
            public MrukOnRoomAnchorRemoved onRoomAnchorRemoved;
            public MrukOnSceneAnchorAdded onSceneAnchorAdded;
            public MrukOnSceneAnchorUpdated onSceneAnchorUpdated;
            public MrukOnSceneAnchorRemoved onSceneAnchorRemoved;
            public MrukOnDiscoveryFinished onDiscoveryFinished;
            public MrukOnTrackersConfigured onTrackersConfigured;
            public MrukOnTrackableAdded onTrackableAdded;
            public MrukOnTrackableUpdated onTrackableUpdated;
            public MrukOnTrackableRemoved onTrackableRemoved;
            public IntPtr userContext;
        }

        [StructLayout(LayoutKind.Sequential)]
        public struct MrukHit
        {
            public Guid roomAnchorUuid;
            public Guid sceneAnchorUuid;
            public float hitDistance;
            public Vector3 hitPosition;
            public Vector3 hitNormal;
        }

        [StructLayout(LayoutKind.Sequential)]
        public struct MrukSharedRoomsData
        {
            public Guid groupUuid;
            public Guid* roomUuids;
            public uint numRoomUuids;
            public Guid alignmentRoomUuid;
            public Pose roomWorldPoseOnHost;
        }

        [StructLayout(LayoutKind.Sequential)]
        public struct _MrukUuidAlignmentTest
        {
            public byte padding;
            public Guid uuid;
        }

        [StructLayout(LayoutKind.Sequential)]
        public struct MrukEnvironmentRaycastHitPointGetInfo
        {
            public Vector3 startPoint;
            public Vector3 direction;
            public uint filterCount;
            public float maxDistance;
        }

        [StructLayout(LayoutKind.Sequential)]
        public struct MrukEnvironmentRaycastHitPoint
        {
            public MrukEnvironmentRaycastStatus status;
            public Vector3 point;
            public Quaternion orientation;
            public Vector3 normal;
        }

        [StructLayout(LayoutKind.Sequential)]
        public struct MrukCameraIntrinsics
        {
            public Vector2 focalLength;
            public Vector2 principalPoint;
            public Vector3 lensTranslation;
            public Quaternion lensRotation;
            public Vector2Int sensorResolution;
        }

        [StructLayout(LayoutKind.Sequential)]
        public struct MrukConfig
        {
            public string appDataPath;
            [MarshalAs(UnmanagedType.U1)] public bool flipPcaTextureVertically;
            [MarshalAs(UnmanagedType.U1)] public bool isLinearColorSpace;
        }


        /// This allows the engine to intercept the logs from the shared library and print them using the
        /// engine's logging system. Note that the log lines are NOT NULL terminated, and so you must take
        /// into account the length and be careful not to read past it.
        internal delegate void SetLogPrinterDelegate(LogPrinter printer);

        /// This should only be called once on application startup to create the global context. This is a
        /// pre-requisite to call all of the other APIs. When the context is not needed anymore it should be
        /// destroyed with ContextDestroy() to free resources (i.e. when the application is shutdown).
        internal delegate MrukResult CreateGlobalContextDelegate(ref MrukConfig config);

        /// Destroy the global context
        /// This should only be called once on application shutdown.
        internal delegate void DestroyGlobalContextDelegate();

        /// Initialize OpenXR with an external OpenXR instance and session.
        /// This should only be called once on application startup.
        /// Make sure to hook up the OnOpenXrEvent() function as well.
        /// If the context is not needed anymore it should be destroyed with ContextDestroy() to free
        /// resources.
        internal delegate MrukResult InitOpenXrDelegate(ulong xrInstance, ulong xrSession, IntPtr xrInstanceProcAddrFunc, ulong baseSpace, string[] availableOpenXrExtensions, uint availableOpenXrExtensionsCount);

        /// This should be called when the OpenXR instance is destroyed and it is no longer valid to attempt
        /// to make any OpenXR calls. This can happen with Link when exiting play mode.
        internal delegate void ShutdownOpenXrDelegate();

        /// Initialize the Unity interfaces. This should be called once after the global context has been
        /// created. See https://docs.unity3d.com/6000.1/Documentation/Manual/native-plugin-interface.html
        /// for more details. Note that the usual UnityPluginLoad and UnityPluginUnload functions will not
        /// be called automatically by unity because the MRUK Shared Library is loaded dynamically at
        /// runtime to allow hot reloading. So we must explicitly call this ourselves to get access to the
        /// interface.
        ///
        /// @param[in] unityInterfaces A pointer to IUnityInterfaces
        internal delegate void InitUnityInterfacesDelegate(IntPtr unityInterfaces);

        /// If the base space changes after initialization, this function should be called to update the
        /// base space.
        internal delegate void SetBaseSpaceDelegate(ulong baseSpace);

        /// Start anchor discovery in the global context
        internal delegate MrukResult StartDiscoveryDelegate([MarshalAs(UnmanagedType.U1)] bool shouldRemoveMissingRooms, MrukSceneModel sceneModel);

        /// Start anchor query from shared group uuid in the global context
        internal delegate MrukResult StartQueryByLocalGroupDelegate(MrukSharedRoomsData sharedRoomsData, [MarshalAs(UnmanagedType.U1)] bool shouldRemoveMissingRooms, MrukSceneModel sceneModel);

        /// Load the scene from a json string
        internal delegate MrukResult LoadSceneFromJsonDelegate(string jsonString, [MarshalAs(UnmanagedType.U1)] bool shouldRemoveMissingRooms, MrukSceneModel sceneModel);

        /// Save the scene to a json string.
        /// @return The serialized JSON string. This string must be freed with FreeJson after use!
        internal delegate char* SaveSceneToJsonDelegate([MarshalAs(UnmanagedType.U1)] bool includeGlobalMesh, Guid[] roomUuids, uint numRoomUuids);

        /// Free the json string returned by SaveSceneToJson.
        /// @param[in] jsonString The JSON string to free.
        internal delegate void FreeJsonDelegate(char* jsonString);

        /// Given a prefabricated scene description, load it in the global context.
        internal delegate MrukResult LoadSceneFromPrefabDelegate(MrukRoomAnchor* roomAnchors, uint numRoomAnchors, MrukSceneAnchor* sceneAnchors, uint numSceneAnchors);

        /// Clear and remove all rooms in the global context.
        internal delegate void ClearRoomsDelegate();

        /// Clear and remove the room that matches the given uuid.
        internal delegate void ClearRoomDelegate(Guid roomUuid);

        /// Allows to forward OpenXR events from the engine into the shared library
        internal delegate void OnOpenXrEventDelegate(IntPtr baseEventHeader);

        /// Needs to be called every tick by the engine.
        internal delegate void TickGlobalContextDelegate(ulong nextPredictedDisplayTime);
        internal delegate void RegisterEventListenerDelegate(MrukEventListener listener);

        /// Cast a ray against all anchors in the room and return the first hit.
        /// A maxDistance of <= 0 will return the first hit regardless of distance.
        [return: MarshalAs(UnmanagedType.U1)]
        internal delegate bool RaycastRoomDelegate(Guid roomUuid, Vector3 origin, Vector3 direction, float maxDistance, MrukLabelFilter labelFilter, ref MrukHit outHit);

        /// Cast a ray against all anchors in the room and return all hits along the ray.
        /// A maxDistance of <= 0 will return the hits along the ray regardless of distance.
        [return: MarshalAs(UnmanagedType.U1)]
        internal delegate bool RaycastRoomAllDelegate(Guid roomUuid, Vector3 origin, Vector3 direction, float maxDistance, MrukLabelFilter labelFilter, ref MrukHit outHits, ref uint outHitsCount);

        /// Cast a ray against the anchor in the room and return the first hit.
        /// A maxDistance of <= 0 will return the hits along the ray regardless of distance.
        [return: MarshalAs(UnmanagedType.U1)]
        internal delegate bool RaycastAnchorDelegate(Guid sceneAnchorUuid, Vector3 origin, Vector3 direction, float maxDistance, uint surfaceTypes, ref MrukHit outHit);

        /// Cast a ray against the anchor in the room and return all hits along the ray.
        /// A maxDistance of <= 0 will return the hits along the ray regardless of distance.
        [return: MarshalAs(UnmanagedType.U1)]
        internal delegate bool RaycastAnchorAllDelegate(Guid sceneAnchorUuid, Vector3 origin, Vector3 direction, float maxDistance, uint surfaceTypes, ref MrukHit outHits, ref uint outHitsCount);

        /// Check if the given position is in the room or not.
        ///
        /// @param[in] roomUuid The unique identifier for the room.
        /// @param[in] position The 3D position to check.
        /// @param[in] testVerticalBounds A boolean indicating whether to test vertical bounds. If false
        /// then the point will be considered inside as long as it is within the perimeter of the room
        /// regardless of whether the point is below the floor or above the ceiling.
        /// @return True if the position is within the room, false otherwise.
        [return: MarshalAs(UnmanagedType.U1)]
        internal delegate bool IsPositionInRoomDelegate(Guid roomUuid, Vector3 position, [MarshalAs(UnmanagedType.U1)] bool testVerticalBounds);

        /// Gets the current room the headset is in. If the headset is not in any given room
        /// then it will return the room the headset was last in when this function was called.
        /// If the headset hasn't been in a valid room yet then return the first room in the list.
        /// If no rooms have been loaded yet then return false.
        ///
        /// @param[out] outRoomUuid Pointer to a MrukUuid that will be filled with the current room UUID.
        /// @return True if a room was found, false otherwise.
        [return: MarshalAs(UnmanagedType.U1)]
        internal delegate bool GetCurrentRoomDelegate(ref Guid outRoomUuid);

        /// Checks whether scene anchor discovery is currently in progress.
        ///
        /// @return True if discovery is ongoing (either actively loading scene data or
        /// performing background processing like BVH building), false if discovery
        /// hasn't started yet or has completely finished.
        [return: MarshalAs(UnmanagedType.U1)]
        internal delegate bool IsDiscoveryRunningDelegate();

        /// Set a custom world lock anchor. This is used to lock the world space to a specific anchor.
        /// @param[in] anchorHandle The anchor handle to lock the world space to. If set to 0 then the world
        /// lock anchor falls back to the default world lock anchor.
        /// @param[in] initialPose The initial pose of the world lock anchor.
        [return: MarshalAs(UnmanagedType.U1)]
        internal delegate bool SetCustomWorldLockAnchorDelegate(ulong anchorHandle, Pose initialPose);

        /// Erase the persisted spatial world locking anchor. This should really only be called for
        /// debugging purposes, internally.
        [return: MarshalAs(UnmanagedType.U1)]
        internal delegate bool ErasePersistedWorldLockAnchorDelegate();

        /// Get the world lock offset for the current room. This is the difference between the room's
        /// initial pose when it was created and the current pose.
        [return: MarshalAs(UnmanagedType.U1)]
        internal delegate bool GetWorldLockOffsetDelegate(ref Pose offset);

        /// Add two vectors together. This is implemented as a test to ensure the native shared
        /// library is working correctly.
        ///
        /// @param[in] a The first vector.
        /// @param[in] b The second vector.
        /// @return The sum of the two vectors.
        internal delegate Vector3 AddVectorsDelegate(Vector3 a, Vector3 b);

        /// Triangulate a polygon with holes, any winding order works. The first polyline defines the main
        /// polygon. Following polylines define holes. This function will allocate memory for the vertices
        /// and indices. You *MUST* call FreeMesh() when you are done with it or you will leak memory.
        ///
        /// @param[in] polygons The polygon to triangulate.
        /// @param[in] numPolygons The number of polygons in the array.
        /// @return mesh The triangulated mesh.
        internal delegate MrukMesh2f TriangulatePolygonDelegate(MrukPolygon2f[] polygons, uint numPolygons);

        /// Free the memory allocated by TriangulatePolygon.
        ///
        /// @param[in] mesh The mesh to free.
        internal delegate void FreeMeshDelegate(ref MrukMesh2f mesh);

        /// Compute the mesh segmentation for a given set of vertices, indices and points per unit.
        /// The function will automatically generate segmentation points in a uniform voxel grid
        /// within the mesh bounds. You *MUST* call FreeMeshSegmentation() on the meshSegments array when
        /// you are done with it or you will leak memory.
        ///
        /// @param[in] vertices The mesh vertices.
        /// @param[in] numVertices The number of vertices in the mesh.
        /// @param[in] indices The mesh indices.
        /// @param[in] numIndices The number of indices in the mesh.
        /// @param[in] pointsPerUnitX The number of points per unit along the X axis.
        /// @param[in] pointsPerUnitY The number of points per unit along the Y axis.
        /// @param[in] pointsPerUnitZ The number of points per unit along the Z axis.
        /// @param[in] reservedMin The minimum bounding box for the reserved segment.
        /// @param[in] reservedMax The maximum bounding box for the reserved segment.
        /// @param[out] meshSegments The resulting segments.
        /// @param[out] numSegments The number of segments in the resulting array.
        /// @param[out] reservedSegment The segment that is inside the reserved bounding box.
        internal delegate MrukResult ComputeMeshSegmentationDelegate(Vector3[] vertices, uint numVertices, uint[] indices, uint numIndices, float pointsPerUnitX, float pointsPerUnitY, float pointsPerUnitZ, Vector3 reservedMin, Vector3 reservedMax, out MrukMesh3f* meshSegments, out uint numSegments, out MrukMesh3f reservedSegment);

        /// Free the memory allocated by ComputeMeshSegmentation.
        ///
        /// @param[in] meshSegments The array of segments to free.
        /// @param[in] numSegments The number of segments in the array.
        /// @param[in] reservedSegment The reserved segment to free.
        internal delegate void FreeMeshSegmentationDelegate(MrukMesh3f* meshSegments, uint numSegments, ref MrukMesh3f reservedSegment);

        /// The is a test function purely to test the marshalling of Uuid from C# to C++. It ensures that
        /// the packing between clang C++ and the C# definitions of MrukUuid are compatible.
        ///
        /// @param[in] packedUuid A uuid packed into a structure.
        /// @return A copy of the uuid that was passed in the structure.
        internal delegate Guid _TestUuidMarshallingDelegate(_MrukUuidAlignmentTest packedUuid);

        /// Converts the given label to the matching MrukLabel.
        ///
        /// @param[in] label The label as string.
        /// @return The converted MrukLabel.
        internal delegate MrukLabel StringToMrukLabelDelegate(string label);

        /// Creates the enviornment raycaster and fires the onEnvironmentRaycasterCreated event when the
        /// creation is complete.
        internal delegate MrukResult CreateEnvironmentRaycasterDelegate();

        /// Destroys the enviornment raycaster.
        internal delegate void DestroyEnvironmentRaycasterDelegate();

        /// Check the status of the environment raycaster.
        internal delegate MrukEnvironmentRaycasterStatus EnvironmentRaycasterStatusDelegate();

        /// Performs an environment raycast.
        /// Ensure that the environment raycaster is created before calling this function.
        /// @param[in] info The raycast info.
        /// @param[out] hitPoint The hit point.
        internal delegate MrukResult RaycastEnvironmentDelegate(ref MrukEnvironmentRaycastHitPointGetInfo info, ref MrukEnvironmentRaycastHitPoint hitPoint);
        internal delegate void SetTrackingSpacePoseGetterDelegate(TrackingSpacePoseGetter getter);
        internal delegate void SetTrackingSpacePoseSetterDelegate(TrackingSpacePoseSetter setter);

        /// Configures the tracker services. This should only be called after the global context
        /// has been created. The trackers that should be enabled can be passed in trackableMask.
        /// 0 means all trackers will be disabled.
        /// The event onTrackersConfigured will be emitted after the tracker service is ready or failed to
        /// start.
        ///
        /// @param[in] trackableMask A bitmask of MrukTrackableType
        internal delegate void ConfigureTrackersDelegate(uint trackableMask);

        /// Set the interval in which trackers will be queried from the system and updated.
        /// @param[in] millseconds Time in millseconds between updates
        internal delegate void SetTrackersUpdateIntervalDelegate(ulong millseconds);

        /// Checks if QR code tracking is supported by the current system.
        ///
        /// @return True if QR code tracking is supported, false otherwise.
        [return: MarshalAs(UnmanagedType.U1)]
        internal delegate bool CheckQrCodeTrackingSupportedDelegate();

        /// Gets the supported resolutions for the specified camera.
        /// This function allocates a buffer in C++ and returns a pointer to it.
        /// The caller is responsible for freeing the buffer by calling CameraFreeSupportedResolutions.
        ///
        /// @param[in] eyeIndex The index of the camera.
        /// @param[out] len Will be set to the number of available resolutions.
        /// @return A pointer to an array of MrukVector2i structures, where x is the width and y is the
        /// height. The caller must free this buffer by calling CameraFreeSupportedResolutions. Returns NULL
        /// if no resolutions are available or an error occurred.
        internal delegate Vector2Int* CameraGetSupportedResolutionsDelegate(int eyeIndex, ref int len);

        /// Frees the buffer allocated by CameraGetSupportedResolutions.
        ///
        /// @param[in] buffer The buffer to free.
        internal delegate void CameraFreeSupportedResolutionsDelegate(Vector2Int* buffer);

        /// Starts the camera capture for the specified camera.
        /// @param[in] eyeIndex The index of the camera to start.
        /// @param[out] width The width of the camera frames that will be captured.
        /// @param[out] height The height of the camera frames that will be captured.
        /// @param[out] intrinsics The intrinsic parameters of the camera.
        /// @param[in] maxFramerate The maximum frames per second for the camera stream.
        /// @return True if the camera was successfully started, false otherwise.
        [return: MarshalAs(UnmanagedType.U1)]
        internal delegate bool CameraPlayDelegate(int eyeIndex, ref int width, ref int height, ref MrukCameraIntrinsics intrinsics, int maxFramerate);

        /// If CameraPlay() returns `true`, the engine should create a render texture and pass its
        /// `nativeTex` pointer to this function. Shared library will update the `nativeTex` directly when
        /// CameraGetUpdateNativeTextureFunc() is called.
        ///
        /// @param[in] eyeIndex The index of the camera for which the native texture is being set.
        /// @param[in] nativeTex A pointer to the native texture created in the engine.
        internal delegate void CameraSetNativeTextureFromUnityDelegate(int eyeIndex, IntPtr nativeTex);

        /// Sets the native Vulkan texture for the specified camera eye.
        /// This function should be called after CameraPlay() has started the camera,
        /// and a Vulkan texture has been created in the engine. The shared library
        /// will use the provided Vulkan texture for camera image updates.
        ///
        /// @param[in] eyeIndex The index of the camera for which the native Vulkan texture is being set.
        /// @param[in] nativeTex A handle to the Vulkan texture created in the engine.
        internal delegate void CameraSetNativeTextureVulkanDelegate(int eyeIndex, ulong nativeTex);

        /// Should be called on the render thread if CameraGetLatestImage() returns `true` in the current
        /// frame.
        /// @param[in] eyeIndex Index of the camera eye.
        internal delegate void CameraUpdateNativeTextureDelegate(int eyeIndex);

        /// Call this function on the Unity render thread of the application when it launches. It
        /// initializes the necessary GPU code to process camera images.
        ///
        /// @param[in] unused Unused parameter. Left in the signature for compatibility with Unitys calling
        /// conventions.
        internal delegate void CameraInitializeFromUnityDelegate(int unused);

        /// Initializes the Vulkan backend for camera image processing.
        /// This function should be called after the Vulkan instance, physical device, and logical device
        /// have been created in the engine. The shared library will use the provided Vulkan handles to
        /// manage camera image resources and perform GPU operations.
        /// This function should be called on the render thread of the application.
        ///
        /// @param[in] vulkanInstance         Handle to the Vulkan instance.
        /// @param[in] vulkanPhysicalDevice   Handle to the Vulkan physical device.
        /// @param[in] vulkanDevice           Handle to the Vulkan logical device.
        /// @param[in] graphicsQueue          Handle to the Vulkan graphics queue.
        /// @param[in] queueFamilyIndex       Index of the queue family used for graphics operations.
        /// @param[in] vulkanGetProcAddrFunc  Pointer to the vkGetInstanceProcAddr function.
        internal delegate void CameraInitializeVulkanDelegate(ulong vulkanInstance, ulong vulkanPhysicalDevice, ulong vulkanDevice, ulong graphicsQueue, uint queueFamilyIndex, IntPtr vulkanGetProcAddrFunc);

        /// Deinitialize the GPU code. In Unity this will be called automatically in this library.
        internal delegate void CameraDeinitializeDelegate();

        /// Acquires the latest image from the camera and adds it to a queue. This function should be called
        /// from the engine's main thread early in the frame. If this function returns `true`, the engine
        /// should schedule a call to CameraGetUpdateNativeTextureFunc() on the render thread. In Unity,
        /// it's done with GL.IssuePluginEvent().
        /// @param[in] eyeIndex The index of the camera.
        /// @param[out] timestampMicrosecondsRealtime Timestamp of the image in microseconds since
        /// the Unix epoch.
        /// @param[out] timestampNsMonotonic Timestamp of the image in monotonic nanoseconds. Used for
        /// getting the precise headset pose at the image's timestamp.
        /// @return `true` if the image was successfully enqueued, `false` otherwise.
        [return: MarshalAs(UnmanagedType.U1)]
        internal delegate bool CameraGetLatestImageDelegate(int eyeIndex, ref long outTimestampMicrosecondsRealtime, ref long outTimestampNsMonotonic);

        /// Notifies the camera system that the application has gained focus.
        /// This should be called when the application regains focus after being in the background.
        internal delegate void CameraOnApplicationFocusedDelegate();

        /// Stops the camera capture for the specified camera.
        /// @param[in] eyeIndex The index of the camera to stop.
        internal delegate void CameraStopDelegate(int eyeIndex);

        /// Acquires the latest image from the camera.
        /// The caller must call CameraReleaseLatestImage() afterwards, even if the returned buffer is null.
        /// @param[in] eyeIndex The index of the camera.
        /// @param[out] timestampMicrosecondsRealtime Timestamp of the image in microseconds since
        /// the Unix epoch.
        /// @param[out] timestampNsMonotonic Timestamp of the image in monotonic nanoseconds. Used for
        /// getting the precise headset pose at the image's timestamp.
        /// @return A pointer to a buffer containing the RGBA (32 bits, 8 bits per channel) image data. If
        /// null, this means no new image is available.
        internal delegate byte* CameraAcquireLatestCpuImageDelegate(int eyeIndex, ref long timestampMicrosecondsRealtime, ref long timestampNsMonotonic);

        /// Releases the image buffer acquired by CameraAcquireLatestImage().
        /// Must be called even if CameraAcquireLatestImage() returns null.
        internal delegate void CameraReleaseLatestCpuImageDelegate(int eyeIndex);

        /// Converts a timestamp in nanoseconds to seconds in XR time domain.
        ///
        /// @param[in] timeNsMonotonic The timestamp in nanoseconds (monotonic clock).
        /// @return The corresponding time in seconds as a double.
        internal delegate double ConvertToXrTimeInSecondsDelegate(long timeNsMonotonic);

        /// Get the headset's pose at the given timestamp
        /// @param[in] time The timestamp in nanoseconds
        /// @param[out] outPosition The headset position
        /// @param[out] outOrientation The headset orientation
        internal delegate void GetHeadsetPoseAtTimeDelegate(long time, Vector3* outPosition, Quaternion* outOrientation);

        internal static SetLogPrinterDelegate SetLogPrinter;
        internal static CreateGlobalContextDelegate CreateGlobalContext;
        internal static DestroyGlobalContextDelegate DestroyGlobalContext;
        internal static InitOpenXrDelegate InitOpenXr;
        internal static ShutdownOpenXrDelegate ShutdownOpenXr;
        internal static InitUnityInterfacesDelegate InitUnityInterfaces;
        internal static SetBaseSpaceDelegate SetBaseSpace;
        internal static StartDiscoveryDelegate StartDiscovery;
        internal static StartQueryByLocalGroupDelegate StartQueryByLocalGroup;
        internal static LoadSceneFromJsonDelegate LoadSceneFromJson;
        internal static SaveSceneToJsonDelegate SaveSceneToJson;
        internal static FreeJsonDelegate FreeJson;
        internal static LoadSceneFromPrefabDelegate LoadSceneFromPrefab;
        internal static ClearRoomsDelegate ClearRooms;
        internal static ClearRoomDelegate ClearRoom;
        internal static OnOpenXrEventDelegate OnOpenXrEvent;
        internal static TickGlobalContextDelegate TickGlobalContext;
        internal static RegisterEventListenerDelegate RegisterEventListener;
        internal static RaycastRoomDelegate RaycastRoom;
        internal static RaycastRoomAllDelegate RaycastRoomAll;
        internal static RaycastAnchorDelegate RaycastAnchor;
        internal static RaycastAnchorAllDelegate RaycastAnchorAll;
        internal static IsPositionInRoomDelegate IsPositionInRoom;
        internal static GetCurrentRoomDelegate GetCurrentRoom;
        internal static IsDiscoveryRunningDelegate IsDiscoveryRunning;
        internal static SetCustomWorldLockAnchorDelegate SetCustomWorldLockAnchor;
        internal static ErasePersistedWorldLockAnchorDelegate ErasePersistedWorldLockAnchor;
        internal static GetWorldLockOffsetDelegate GetWorldLockOffset;
        internal static AddVectorsDelegate AddVectors;
        internal static TriangulatePolygonDelegate TriangulatePolygon;
        internal static FreeMeshDelegate FreeMesh;
        internal static ComputeMeshSegmentationDelegate ComputeMeshSegmentation;
        internal static FreeMeshSegmentationDelegate FreeMeshSegmentation;
        internal static _TestUuidMarshallingDelegate _TestUuidMarshalling;
        internal static StringToMrukLabelDelegate StringToMrukLabel;
        internal static CreateEnvironmentRaycasterDelegate CreateEnvironmentRaycaster;
        internal static DestroyEnvironmentRaycasterDelegate DestroyEnvironmentRaycaster;
        internal static EnvironmentRaycasterStatusDelegate EnvironmentRaycasterStatus;
        internal static RaycastEnvironmentDelegate RaycastEnvironment;
        internal static SetTrackingSpacePoseGetterDelegate SetTrackingSpacePoseGetter;
        internal static SetTrackingSpacePoseSetterDelegate SetTrackingSpacePoseSetter;
        internal static ConfigureTrackersDelegate ConfigureTrackers;
        internal static SetTrackersUpdateIntervalDelegate SetTrackersUpdateInterval;
        internal static CheckQrCodeTrackingSupportedDelegate CheckQrCodeTrackingSupported;
        internal static CameraGetSupportedResolutionsDelegate CameraGetSupportedResolutions;
        internal static CameraFreeSupportedResolutionsDelegate CameraFreeSupportedResolutions;
        internal static CameraPlayDelegate CameraPlay;
        internal static CameraSetNativeTextureFromUnityDelegate CameraSetNativeTextureFromUnity;
        internal static CameraSetNativeTextureVulkanDelegate CameraSetNativeTextureVulkan;
        internal static CameraUpdateNativeTextureDelegate CameraUpdateNativeTexture;
        internal static CameraInitializeFromUnityDelegate CameraInitializeFromUnity;
        internal static CameraInitializeVulkanDelegate CameraInitializeVulkan;
        internal static CameraDeinitializeDelegate CameraDeinitialize;
        internal static CameraGetLatestImageDelegate CameraGetLatestImage;
        internal static CameraOnApplicationFocusedDelegate CameraOnApplicationFocused;
        internal static CameraStopDelegate CameraStop;
        internal static CameraAcquireLatestCpuImageDelegate CameraAcquireLatestCpuImage;
        internal static CameraReleaseLatestCpuImageDelegate CameraReleaseLatestCpuImage;
        internal static ConvertToXrTimeInSecondsDelegate ConvertToXrTimeInSeconds;
        internal static GetHeadsetPoseAtTimeDelegate GetHeadsetPoseAtTime;

        internal static void LoadNativeFunctions()
        {
            SetLogPrinter = MRUKNative.LoadFunction<SetLogPrinterDelegate>("SetLogPrinter");
            CreateGlobalContext = MRUKNative.LoadFunction<CreateGlobalContextDelegate>("CreateGlobalContext");
            DestroyGlobalContext = MRUKNative.LoadFunction<DestroyGlobalContextDelegate>("DestroyGlobalContext");
            InitOpenXr = MRUKNative.LoadFunction<InitOpenXrDelegate>("InitOpenXr");
            ShutdownOpenXr = MRUKNative.LoadFunction<ShutdownOpenXrDelegate>("ShutdownOpenXr");
            InitUnityInterfaces = MRUKNative.LoadFunction<InitUnityInterfacesDelegate>("InitUnityInterfaces");
            SetBaseSpace = MRUKNative.LoadFunction<SetBaseSpaceDelegate>("SetBaseSpace");
            StartDiscovery = MRUKNative.LoadFunction<StartDiscoveryDelegate>("StartDiscovery");
            StartQueryByLocalGroup = MRUKNative.LoadFunction<StartQueryByLocalGroupDelegate>("StartQueryByLocalGroup");
            LoadSceneFromJson = MRUKNative.LoadFunction<LoadSceneFromJsonDelegate>("LoadSceneFromJson");
            SaveSceneToJson = MRUKNative.LoadFunction<SaveSceneToJsonDelegate>("SaveSceneToJson");
            FreeJson = MRUKNative.LoadFunction<FreeJsonDelegate>("FreeJson");
            LoadSceneFromPrefab = MRUKNative.LoadFunction<LoadSceneFromPrefabDelegate>("LoadSceneFromPrefab");
            ClearRooms = MRUKNative.LoadFunction<ClearRoomsDelegate>("ClearRooms");
            ClearRoom = MRUKNative.LoadFunction<ClearRoomDelegate>("ClearRoom");
            OnOpenXrEvent = MRUKNative.LoadFunction<OnOpenXrEventDelegate>("OnOpenXrEvent");
            TickGlobalContext = MRUKNative.LoadFunction<TickGlobalContextDelegate>("TickGlobalContext");
            RegisterEventListener = MRUKNative.LoadFunction<RegisterEventListenerDelegate>("RegisterEventListener");
            RaycastRoom = MRUKNative.LoadFunction<RaycastRoomDelegate>("RaycastRoom");
            RaycastRoomAll = MRUKNative.LoadFunction<RaycastRoomAllDelegate>("RaycastRoomAll");
            RaycastAnchor = MRUKNative.LoadFunction<RaycastAnchorDelegate>("RaycastAnchor");
            RaycastAnchorAll = MRUKNative.LoadFunction<RaycastAnchorAllDelegate>("RaycastAnchorAll");
            IsPositionInRoom = MRUKNative.LoadFunction<IsPositionInRoomDelegate>("IsPositionInRoom");
            GetCurrentRoom = MRUKNative.LoadFunction<GetCurrentRoomDelegate>("GetCurrentRoom");
            IsDiscoveryRunning = MRUKNative.LoadFunction<IsDiscoveryRunningDelegate>("IsDiscoveryRunning");
            SetCustomWorldLockAnchor = MRUKNative.LoadFunction<SetCustomWorldLockAnchorDelegate>("SetCustomWorldLockAnchor");
            ErasePersistedWorldLockAnchor = MRUKNative.LoadFunction<ErasePersistedWorldLockAnchorDelegate>("ErasePersistedWorldLockAnchor");
            GetWorldLockOffset = MRUKNative.LoadFunction<GetWorldLockOffsetDelegate>("GetWorldLockOffset");
            AddVectors = MRUKNative.LoadFunction<AddVectorsDelegate>("AddVectors");
            TriangulatePolygon = MRUKNative.LoadFunction<TriangulatePolygonDelegate>("TriangulatePolygon");
            FreeMesh = MRUKNative.LoadFunction<FreeMeshDelegate>("FreeMesh");
            ComputeMeshSegmentation = MRUKNative.LoadFunction<ComputeMeshSegmentationDelegate>("ComputeMeshSegmentation");
            FreeMeshSegmentation = MRUKNative.LoadFunction<FreeMeshSegmentationDelegate>("FreeMeshSegmentation");
            _TestUuidMarshalling = MRUKNative.LoadFunction<_TestUuidMarshallingDelegate>("_TestUuidMarshalling");
            StringToMrukLabel = MRUKNative.LoadFunction<StringToMrukLabelDelegate>("StringToMrukLabel");
            CreateEnvironmentRaycaster = MRUKNative.LoadFunction<CreateEnvironmentRaycasterDelegate>("CreateEnvironmentRaycaster");
            DestroyEnvironmentRaycaster = MRUKNative.LoadFunction<DestroyEnvironmentRaycasterDelegate>("DestroyEnvironmentRaycaster");
            EnvironmentRaycasterStatus = MRUKNative.LoadFunction<EnvironmentRaycasterStatusDelegate>("EnvironmentRaycasterStatus");
            RaycastEnvironment = MRUKNative.LoadFunction<RaycastEnvironmentDelegate>("RaycastEnvironment");
            SetTrackingSpacePoseGetter = MRUKNative.LoadFunction<SetTrackingSpacePoseGetterDelegate>("SetTrackingSpacePoseGetter");
            SetTrackingSpacePoseSetter = MRUKNative.LoadFunction<SetTrackingSpacePoseSetterDelegate>("SetTrackingSpacePoseSetter");
            ConfigureTrackers = MRUKNative.LoadFunction<ConfigureTrackersDelegate>("ConfigureTrackers");
            SetTrackersUpdateInterval = MRUKNative.LoadFunction<SetTrackersUpdateIntervalDelegate>("SetTrackersUpdateInterval");
            CheckQrCodeTrackingSupported = MRUKNative.LoadFunction<CheckQrCodeTrackingSupportedDelegate>("CheckQrCodeTrackingSupported");
            CameraGetSupportedResolutions = MRUKNative.LoadFunction<CameraGetSupportedResolutionsDelegate>("CameraGetSupportedResolutions");
            CameraFreeSupportedResolutions = MRUKNative.LoadFunction<CameraFreeSupportedResolutionsDelegate>("CameraFreeSupportedResolutions");
            CameraPlay = MRUKNative.LoadFunction<CameraPlayDelegate>("CameraPlay");
            CameraSetNativeTextureFromUnity = MRUKNative.LoadFunction<CameraSetNativeTextureFromUnityDelegate>("CameraSetNativeTextureFromUnity");
            CameraSetNativeTextureVulkan = MRUKNative.LoadFunction<CameraSetNativeTextureVulkanDelegate>("CameraSetNativeTextureVulkan");
            CameraUpdateNativeTexture = MRUKNative.LoadFunction<CameraUpdateNativeTextureDelegate>("CameraUpdateNativeTexture");
            CameraInitializeFromUnity = MRUKNative.LoadFunction<CameraInitializeFromUnityDelegate>("CameraInitializeFromUnity");
            CameraInitializeVulkan = MRUKNative.LoadFunction<CameraInitializeVulkanDelegate>("CameraInitializeVulkan");
            CameraDeinitialize = MRUKNative.LoadFunction<CameraDeinitializeDelegate>("CameraDeinitialize");
            CameraGetLatestImage = MRUKNative.LoadFunction<CameraGetLatestImageDelegate>("CameraGetLatestImage");
            CameraOnApplicationFocused = MRUKNative.LoadFunction<CameraOnApplicationFocusedDelegate>("CameraOnApplicationFocused");
            CameraStop = MRUKNative.LoadFunction<CameraStopDelegate>("CameraStop");
            CameraAcquireLatestCpuImage = MRUKNative.LoadFunction<CameraAcquireLatestCpuImageDelegate>("CameraAcquireLatestCpuImage");
            CameraReleaseLatestCpuImage = MRUKNative.LoadFunction<CameraReleaseLatestCpuImageDelegate>("CameraReleaseLatestCpuImage");
            ConvertToXrTimeInSeconds = MRUKNative.LoadFunction<ConvertToXrTimeInSecondsDelegate>("ConvertToXrTimeInSeconds");
            GetHeadsetPoseAtTime = MRUKNative.LoadFunction<GetHeadsetPoseAtTimeDelegate>("GetHeadsetPoseAtTime");
        }

        internal static void UnloadNativeFunctions()
        {
            SetLogPrinter = null;
            CreateGlobalContext = null;
            DestroyGlobalContext = null;
            InitOpenXr = null;
            ShutdownOpenXr = null;
            InitUnityInterfaces = null;
            SetBaseSpace = null;
            StartDiscovery = null;
            StartQueryByLocalGroup = null;
            LoadSceneFromJson = null;
            SaveSceneToJson = null;
            FreeJson = null;
            LoadSceneFromPrefab = null;
            ClearRooms = null;
            ClearRoom = null;
            OnOpenXrEvent = null;
            TickGlobalContext = null;
            RegisterEventListener = null;
            RaycastRoom = null;
            RaycastRoomAll = null;
            RaycastAnchor = null;
            RaycastAnchorAll = null;
            IsPositionInRoom = null;
            GetCurrentRoom = null;
            IsDiscoveryRunning = null;
            SetCustomWorldLockAnchor = null;
            ErasePersistedWorldLockAnchor = null;
            GetWorldLockOffset = null;
            AddVectors = null;
            TriangulatePolygon = null;
            FreeMesh = null;
            ComputeMeshSegmentation = null;
            FreeMeshSegmentation = null;
            _TestUuidMarshalling = null;
            StringToMrukLabel = null;
            CreateEnvironmentRaycaster = null;
            DestroyEnvironmentRaycaster = null;
            EnvironmentRaycasterStatus = null;
            RaycastEnvironment = null;
            SetTrackingSpacePoseGetter = null;
            SetTrackingSpacePoseSetter = null;
            ConfigureTrackers = null;
            SetTrackersUpdateInterval = null;
            CheckQrCodeTrackingSupported = null;
            CameraGetSupportedResolutions = null;
            CameraFreeSupportedResolutions = null;
            CameraPlay = null;
            CameraSetNativeTextureFromUnity = null;
            CameraSetNativeTextureVulkan = null;
            CameraUpdateNativeTexture = null;
            CameraInitializeFromUnity = null;
            CameraInitializeVulkan = null;
            CameraDeinitialize = null;
            CameraGetLatestImage = null;
            CameraOnApplicationFocused = null;
            CameraStop = null;
            CameraAcquireLatestCpuImage = null;
            CameraReleaseLatestCpuImage = null;
            ConvertToXrTimeInSeconds = null;
            GetHeadsetPoseAtTime = null;
        }

    }
}
